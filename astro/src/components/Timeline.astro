---
const { items, config } = Astro.props as { items: any[], config?: any };

const sorted = [...items].sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

// Map type to display name for cards
const typeDisplayName = (type: string) => {
  const displayNames: Record<string, string> = {
    'saved': 'Article Shared',
    'primer': 'AI Topic Primer',
    'blog': 'Blog',
    'bluesky': 'Bluesky',
    'pixelfed': 'Pixelfed',
    'hackernews': 'HackerNews',
    'posts': 'Posts',
    'release': 'Release',
    'wikipedia': 'Contributions',
    'contributions': 'Contributions',
    'linkedin': 'LinkedIn'
  };
  return displayNames[type] || type.toUpperCase();
};

// Format date as YYYY/MM/DD
const formatShortDate = (timestamp: string) => {
  const date = new Date(timestamp);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}/${month}/${day}`;
};
---

<section class="timeline" aria-label="Timeline">
  <div class="empty-state" id="empty-state" hidden>
    <div class="empty-icon">‚è∞</div>
    <h3>Time Travel Log: SUCCESS!</h3>
    <p>I am back in <strong id="current-date"></strong></p>
    <p>I seem to have traveled back to before there was content on this page.</p>
    <p><a href="#" class="reset-link" id="reset-machine">Reset machine</a> to continue</p>
  </div>
  <ol class="list" role="list" data-pagefind-body>
    <!-- Today marker -->
    <li class="row today-marker">
      <span class="dot today-dot" title="Today"></span>
      <div class="today-label">
        <span class="today-text">Today</span>
        <time class="today-date">{new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}</time>
      </div>
    </li>
    
    {sorted.map((item) => (
      <li id={`node-${item.id.replace(/[^a-zA-Z0-9-]/g, '-')}`} class={`row type-${item.type}`} data-type={item.type} data-id={item.id} data-hashtags={item.hashtags?.join(',') || ''}>
        <button class="card" data-id={item.id} data-type={item.type} data-url={item.type === 'blog' ? `/blog/${item.id.replace('blog:', '')}` : (item.type === 'primer' ? `/primer/${item.id.replace('readwise:', '')}` : (item.url || ''))} aria-haspopup="dialog">
          <span class="card-top-bar" data-card-type={item.type} data-timestamp={item.timestamp} title={new Date(item.timestamp).toLocaleString()}></span>
          <div class="meta">
            <span class="type">{typeDisplayName(item.type)}</span>
            <time datetime={item.timestamp}>{formatShortDate(item.timestamp)}</time>
          </div>
          {item.media?.images && item.media.images.length > 0 && (
            <div class="media-preview">
              {item.media.images.slice(0, 1).map((imageUrl: string, index: number) => (
                <img 
                  src={imageUrl} 
                  alt={item.media?.alt?.[index] || `Image ${index + 1}`}
                  class="preview-image"
                  loading="lazy"
                />
              ))}
              {item.media.images.length > 1 && (
                <span class="image-count">+{item.media.images.length - 1}</span>
              )}
            </div>
          )}
          {item.title && <div class="title">{item.title}</div>}
          {item.summary && !(item.type === 'pixelfed' && item.summary === item.title) && <p class="summary">{item.summary}</p>}
            {(['saved', 'linkedin', 'primer'].includes(item.type) && item.metadata?.site_name) && (
            <div class="card-metadata">
              <span class="metadata-item">üì∞ {item.metadata.site_name}</span>
            </div>
          )}
          {item.hashtags && item.hashtags.length > 0 && (
            <div class="card-hashtags" data-pagefind-weight="2">
              {item.hashtags.map((tag: string) => (
                <span class="card-hashtag" data-hashtag={tag} onclick="event.stopPropagation(); window.dispatchEvent(new CustomEvent('hashtag:click', { detail: { tag: this.dataset.hashtag } }));" role="button" tabindex="0">{tag}</span>
              ))}
            </div>
          )}
          {/* Hidden text for better Pagefind indexing of tags */}
          {item.hashtags && item.hashtags.length > 0 && (
            <span class="sr-only" data-pagefind-meta="tags">{item.hashtags.map((t: string) => t.replace('#', '')).join(' ')}</span>
          )}
        </button>
      </li>
    ))}
  </ol>

  <div id="tooltip" role="tooltip" hidden>
    <div class="tooltip-card">
      <div class="tooltip-title"></div>
      <div class="tooltip-meta"></div>
    </div>
  </div>
</section>

<style>
  .timeline { display: contents; }
  .empty-state { text-align: center; padding: 80px 20px; color: var(--muted); max-width: 600px; margin: 0 auto; }
  .empty-icon { font-size: 64px; margin-bottom: 20px; opacity: 0.8; }
  .empty-state h3 { font-size: 24px; color: var(--text); margin: 0 0 12px; font-weight: 600; }
  .empty-state p { margin: 8px 0; font-size: 16px; line-height: 1.6; }
  .empty-state strong { color: var(--accent); }
  .reset-link { color: var(--accent); text-decoration: underline; cursor: pointer; font-weight: 600; }
  .reset-link:hover { opacity: 0.8; }
  
  /* Timeline list with centered vertical line */
  .list { 
    list-style: none; 
    margin: 0; 
    padding: 0; 
    position: relative; 
  }
  .list::before {
    content: "";
    position: absolute;
    top: 0;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 2px;
    background: var(--spine);
    z-index: 0;
  }
  
  /* Each row - card centered */
  .row { 
    position: relative;
    margin: 0;
    padding-top: 16px;
    transition: background-color 0.3s ease; 
  }
  .row.node-highlighted { background-color: rgba(193, 122, 79, 0.15); border-radius: 8px; }
  
  /* Today dot - only for today marker */
  .dot { 
    position: absolute; 
    left: 50%; 
    top: 0;
    transform: translateX(-50%);
    width: 14px; 
    height: 14px; 
    border-radius: 50%; 
    background: var(--accent); 
    box-shadow: 0 0 0 3px var(--bg); 
    cursor: default; 
    border: 1px solid rgba(0,0,0,0.1); 
    z-index: 2;
  }
  
  /* Today marker styles */
  .today-marker { padding-top: 12px; margin-bottom: 12px; }
  .today-dot { background: var(--accent); cursor: default; animation: pulse 2s ease-in-out infinite; top: 0; }
  .today-dot:hover { transform: translateX(-50%); box-shadow: 0 0 0 3px var(--bg); }
  .today-label { 
    display: flex; 
    align-items: center; 
    justify-content: center;
    gap: 8px; 
    padding-top: 8px;
  }
  .today-text { font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; font-size: 13px; color: var(--accent); font-family: system-ui, sans-serif; }
  .today-date { color: var(--muted); font-size: 13px; font-family: system-ui, sans-serif; }
  @keyframes pulse {
    0%, 100% { box-shadow: 0 0 0 3px var(--bg), 0 0 0 4px var(--accent); }
    50% { box-shadow: 0 0 0 3px var(--bg), 0 0 0 6px var(--accent), 0 0 16px var(--accent); }
  }
  
  /* Card styles */
  .card { 
    text-align: left; 
    background: var(--card-bg); 
    color: var(--text); 
    border: 1px solid var(--border); 
    border-radius: 8px; 
    padding: 14px; 
    padding-top: 18px; /* Extra space for top bar */
    cursor: pointer; 
    width: 100%; 
    transition: all 0.2s; 
    box-shadow: 0 1px 3px rgba(0,0,0,0.05); 
    position: relative; 
    z-index: 1;
    overflow: visible;
  }
  .card:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.1); transform: translateY(-1px); }
  
  /* Top bar - hover target for tooltip */
  .card-top-bar {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    border-radius: 8px 8px 0 0;
    cursor: pointer;
    z-index: 3;
    transition: all 0.2s ease;
  }
  .card-top-bar:hover {
    height: 6px;
    filter: brightness(1.2);
  }
  
  /* Emoji indicator on top bar hover */
  .card-top-bar::after {
    content: "";
    position: absolute;
    top: -16px;
    right: 12px;
    font-size: 20px;
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
  }
  .card-top-bar:hover::after { opacity: 1; }
  
  /* Top bar colors by type */
  .card-top-bar[data-card-type="blog"] { background: #5d4037; }
  .card-top-bar[data-card-type="saved"] { background: #7cb342; }
  .card-top-bar[data-card-type="primer"] { background: #7e57c2; }
  .card-top-bar[data-card-type="bluesky"] { background: #1e88e5; }
  .card-top-bar[data-card-type="pixelfed"] { background: #e91e63; }
  .card-top-bar[data-card-type="hackernews"] { background: #ff6600; }
  .card-top-bar[data-card-type="posts"] { background: #42a5f5; }
  .card-top-bar[data-card-type="release"] { background: #fb8c00; }
  .card-top-bar[data-card-type="wikipedia"] { background: #636466; }
  .card-top-bar[data-card-type="contributions"] { background: #9c27b0; }
  .card-top-bar[data-card-type="linkedin"] { background: #0a66c2; }
  
  /* Emoji by type on top bar hover */
  .card-top-bar[data-card-type="blog"]::after { content: "üìù"; }
  .card-top-bar[data-card-type="saved"]::after { content: "üîñ"; }
  .card-top-bar[data-card-type="primer"]::after { content: "üß†"; }
  .card-top-bar[data-card-type="bluesky"]::after { content: "ü¶ã"; }
  .card-top-bar[data-card-type="pixelfed"]::after { content: "üì∑"; }
  .card-top-bar[data-card-type="hackernews"]::after { content: "üí¨"; }
  .card-top-bar[data-card-type="posts"]::after { content: "ü¶ã"; }
  .card-top-bar[data-card-type="release"]::after { content: "üè∑Ô∏è"; }
  .card-top-bar[data-card-type="wikipedia"]::after { content: "üåê"; }
  .card-top-bar[data-card-type="contributions"]::after { content: "üåê"; }
  .card-top-bar[data-card-type="linkedin"]::after { content: "üíº"; }
  
  .card-link { display: block; text-decoration: none; }
  .meta { display: flex; gap: 10px; font-size: 12px; color: var(--muted); font-family: system-ui, sans-serif; align-items: center; }
  .type { text-transform: uppercase; letter-spacing: .08em; font-weight: 600; }
  .media-indicator { background: rgba(193, 122, 79, 0.15); padding: 2px 6px; border-radius: 4px; font-size: 11px; color: var(--accent); white-space: nowrap; }
  .media-preview { position: relative; display: flex; justify-content: center; margin: 8px 0; }
  .preview-image { width: 126px; height: 126px; border-radius: 8px; object-fit: cover; border: 1px solid var(--border); transition: transform 0.2s; }
  .preview-image:hover { transform: scale(1.05); }
  .image-count { position: absolute; top: -6px; right: -6px; background: var(--accent); color: var(--bg); font-size: 10px; font-weight: 600; padding: 2px 4px; border-radius: 8px; min-width: 16px; text-align: center; line-height: 1; }
  .title { font-weight: 600; margin-top: 6px; color: var(--text); line-height: 1.4; }
  .title-link { text-decoration: none; color: var(--text); display: block; transition: color 0.2s; }
  .title-link:hover { color: var(--accent); text-decoration: underline; }
  .summary { margin: 8px 0 0; color: var(--muted); font-size: 14px; line-height: 1.5; }
  .card-metadata { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border); }
  .metadata-item { font-size: 12px; color: var(--muted); font-family: system-ui, sans-serif; display: flex; align-items: center; gap: 4px; }
  .card-hashtags { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 8px; }
  .card-hashtag { display: inline-block; padding: 2px 8px; border-radius: 999px; background: rgba(193, 122, 79, 0.15); color: var(--accent); font-size: 11px; font-weight: 600; font-family: system-ui, sans-serif; border: 1px solid transparent; cursor: pointer; transition: all 0.2s; }
  .card-hashtag:hover { background: rgba(193, 122, 79, 0.25); border-color: var(--accent); transform: scale(1.05); }
  .card-hashtag:active { transform: scale(0.95); }
  .card-hashtag.hashtag-selected { background: var(--accent); color: var(--bg); border-color: var(--accent); }
  .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }

  #tooltip { position: fixed; z-index: 60; pointer-events: none; }
  .tooltip-card { background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 10px 12px; box-shadow: 0 4px 16px rgba(0,0,0,0.15); max-width: 360px; }
  .tooltip-title { font-weight: 600; font-size: 14px; margin-bottom: 3px; color: var(--text); }
  .tooltip-meta { font-size: 12px; color: var(--muted); font-family: system-ui, sans-serif; }
</style>

<script is:inline set:html={`window.__TIMELINE__ = ${JSON.stringify(sorted)};`} />
{config && <script is:inline set:html={`window.__CONFIG__ = ${JSON.stringify(config)};`} />}

<script>
  const params = new URLSearchParams(location.search);
  const typesParam = (params.get('types') ?? '').split(',').filter(Boolean);

  let activeHashtags = new Set<string>();
  const emptyState = document.getElementById('empty-state');
  const timelineList = document.querySelector('.list');
  const currentDateEl = document.getElementById('current-date');
  const resetMachine = document.getElementById('reset-machine');

  // Set current date in empty state
  if (currentDateEl) {
    currentDateEl.textContent = new Date().toLocaleDateString('en-US', { 
      month: 'long', 
      day: 'numeric', 
      year: 'numeric' 
    });
  }

  // Handle reset machine click
  resetMachine?.addEventListener('click', (e) => {
    e.preventDefault();
    window.location.href = window.location.pathname; // Reload without query params
  });

  // Format date as YYYY/MM/DD
  function formatShortDate(timestamp: string): string {
    const date = new Date(timestamp);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}/${month}/${day}`;
  }

  function checkIfEmpty() {
    const visibleRows = Array.from(document.querySelectorAll('.row:not(.today-marker)') as NodeListOf<HTMLElement>)
      .filter(row => row.style.display !== 'none');
    
    // Update results count
    const resultsCountEl = document.getElementById('results-count');
    const resultsCountNumber = document.getElementById('results-count-number');
    if (resultsCountEl && resultsCountNumber) {
      const count = visibleRows.length;
      resultsCountNumber.textContent = count.toString();
      resultsCountEl.removeAttribute('hidden');
    }
    
    if (visibleRows.length === 0) {
      emptyState?.removeAttribute('hidden');
      timelineList?.setAttribute('hidden', '');
    } else {
      emptyState?.setAttribute('hidden', '');
      timelineList?.removeAttribute('hidden');
    }
  }

  function applyFilters() {
    // Expand comma-separated checkbox values into individual types
    const checkboxValues = Array.from(document.querySelectorAll('input[name="type"]') as NodeListOf<HTMLInputElement>).map(i=>i.value);
    const expandedDefaults = checkboxValues.flatMap(v => v.split(',').filter(Boolean));
    const allowed = new Set(typesParam.length ? typesParam : expandedDefaults);
    
    document.querySelectorAll('.row').forEach((row) => {
      const t = (row as HTMLElement).dataset.type;
      const hashtags = (row as HTMLElement).dataset.hashtags?.split(',').filter(Boolean) || [];
      
      const typeMatch = allowed.size === 0 ? false : allowed.has(t!);
      const hashtagMatch = activeHashtags.size === 0 || hashtags.some(tag => activeHashtags.has(tag));
      
      (row as HTMLElement).style.display = (typeMatch && hashtagMatch) ? '' : 'none';
    });
    checkIfEmpty();
  }
  applyFilters();
  
  document.addEventListener('filters:changed', (e: any) => {
    const allowed = new Set(e.detail.types.length ? e.detail.types : []);
    document.querySelectorAll('.row').forEach((row) => {
      const t = (row as HTMLElement).dataset.type;
      const hashtags = (row as HTMLElement).dataset.hashtags?.split(',').filter(Boolean) || [];
      
      const typeMatch = allowed.size === 0 ? false : allowed.has(t!);
      const hashtagMatch = activeHashtags.size === 0 || hashtags.some(tag => activeHashtags.has(tag));
      
      (row as HTMLElement).style.display = (typeMatch && hashtagMatch) ? '' : 'none';
    });
    checkIfEmpty();
  });

  document.addEventListener('hashtag:changed', (e: any) => {
    activeHashtags = new Set(e.detail.hashtags);
    applyFilters();
  });

  const panel = document.getElementById('detail-panel')!;
  const panelContent = document.getElementById('panel-content')!;
  const panelTitleText = document.getElementById('panel-title-text')!;
  const panelSourceWrapper = document.getElementById('panel-source-wrapper')!;
  const panelSource = document.getElementById('panel-source')! as HTMLAnchorElement;
  const closeBtn = document.getElementById('panel-close-left')!;
  const copyLinkBtn = document.getElementById('panel-copy-link')!;
  const backdrop = document.getElementById('panel-backdrop')!;
  const swipeIndicator = document.getElementById('swipe-indicator')!;
  const isMobile = () => window.innerWidth <= 980;

  // Save intro content - ensure it's captured correctly
  let introHTML = panelContent.innerHTML;
  if (!introHTML || introHTML.trim() === '') {
    console.warn('Panel intro content is empty, attempting to restore...');
    // Fallback to re-reading from DOM
    setTimeout(() => {
      introHTML = panelContent.innerHTML;
    }, 100);
  }

  function lockScroll(lock = true) {
    if (lock && isMobile()) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = '';
    }
  }

  async function loadBlogPost(url: string): Promise<string> {
    try {
      const response = await fetch(url);
      const html = await response.text();
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const article = doc.querySelector('article') || doc.querySelector('main') || doc.querySelector('.content');
      return article ? article.innerHTML : '<p>Unable to load content</p>';
    } catch {
      return '<p>Error loading content</p>';
    }
  }

  async function openPanelFor(id: string) {
    const entry = (window as any).__TIMELINE__.find((i: any) => i.id === id);
    if (!entry) return;
    
    // Mobile: show backdrop and lock scroll, switch to drawer mode
    if (isMobile()) {
      backdrop.removeAttribute('hidden');
      panel.classList.add('mobile-detail-open');
      closeBtn.removeAttribute('hidden');
      copyLinkBtn.removeAttribute('hidden');
      swipeIndicator.removeAttribute('hidden');
      lockScroll(true);
    } else {
      // Desktop: show close button and copy link for detail content
      closeBtn.removeAttribute('hidden');
      copyLinkBtn.removeAttribute('hidden');
      swipeIndicator.setAttribute('hidden', '');
    }

    // Set title to metadata (type and timestamp)
    const panelTypeDisplay: Record<string, string> = {
      'saved': 'Article Shared',
      'primer': 'AI Topic Primer',
      'linkedin': 'LinkedIn',
      'bluesky': 'Posts',
      'pixelfed': 'Photo',
      'hackernews': 'Comment',
      'wikipedia': 'Contributions',
      'contributions': 'Contributions'
    };
    const typeDisplayName = panelTypeDisplay[entry.type] || entry.type.toUpperCase();
    const shortDate = formatShortDate(entry.timestamp);
    panelTitleText.textContent = `${typeDisplayName} ¬∑ ${shortDate}`;
    
    // Show/hide and update source link
    // For blog and primer types, link to their standalone pages
    // For external sources, use canonical_url or url
    let sourceUrl: string | null = null;
    if (entry.type === 'blog') {
      sourceUrl = `/blog/${entry.id.replace('blog:', '')}`;
    } else if (entry.type === 'primer') {
      sourceUrl = `/primer/${entry.id.replace('readwise:', '')}`;
    } else {
      sourceUrl = entry.canonical_url && !entry.canonical_url.startsWith('/') 
        ? entry.canonical_url 
        : (entry.url && !entry.url.startsWith('/') ? entry.url : null);
    }
    
    if (sourceUrl) {
      panelSource.href = sourceUrl;
      panelSourceWrapper.removeAttribute('hidden');
    } else {
      panelSourceWrapper.setAttribute('hidden', '');
    }
    
    // Show loading state
    panelContent.innerHTML = '<p>Loading...</p>';
    
    // Load content based on type
    let content = '';
    if (entry.type === 'blog') {
      const blogUrl = `/blog/${entry.id.replace('blog:', '')}`;
      const blogContent = await loadBlogPost(blogUrl);
      
      // Build hashtags display for blog posts too
      let hashtagsHtml = '';
      if (entry.hashtags && entry.hashtags.length > 0) {
        const hashtagTags = entry.hashtags.map((tag: string) => 
          `<span class="detail-hashtag" data-hashtag="${tag}" role="button" tabindex="0">${tag}</span>`
        ).join('');
        hashtagsHtml = `<div class="detail-hashtags">${hashtagTags}</div>`;
      }
      
      content = `<h3 class="detail-title">${entry.title || ''}</h3>
        <div class="detail-content">${blogContent}</div>
        ${hashtagsHtml}`;
    } else {
      // Build metadata string for saved articles
      let metadataHtml = '';
      if (entry.type === 'saved' || entry.type === 'linkedin' || entry.type === 'primer') {
        const metadataParts = [];
        if (entry.metadata?.site_name) metadataParts.push(`üì∞ ${entry.metadata.site_name}`);
        if (entry.author) metadataParts.push(`‚úçÔ∏è ${entry.author}`);
        if (entry.metadata?.reading_time) metadataParts.push(`‚è±Ô∏è ${entry.metadata.reading_time}`);
        if (metadataParts.length > 0) {
          metadataHtml = `<div class="detail-metadata">${metadataParts.join(' ‚Ä¢ ')}</div>`;
        }
      }
      
      // YouTube embed detection - check metadata, url, content_html, then summary
      let youtubeEmbed = '';
      const youtubeUrlPattern = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{5,})/i;
      let videoId = null;

      // Check metadata.video_id first (most reliable, set during fetch)
      if (entry.metadata?.video_id) {
        videoId = entry.metadata.video_id;
      }

      // Check entry.url
      if (!videoId && entry.url && (entry.url.includes('youtube.com/watch') || entry.url.includes('youtu.be/'))) {
        const match = entry.url.match(youtubeUrlPattern);
        if (match) videoId = match[1];
      }

      // Check content_html (has full URLs, unlike truncated summary)
      if (!videoId && entry.content_html) {
        const match = entry.content_html.match(youtubeUrlPattern);
        if (match) videoId = match[1];
      }

      // Check summary last (may have truncated URLs)
      if (!videoId && entry.summary) {
        const match = entry.summary.match(youtubeUrlPattern);
        if (match) videoId = match[1];
      }
      
      if (videoId) {
        const youtubeUrl = `https://www.youtube.com/watch?v=${videoId}`;
        const thumbUrl = `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
        youtubeEmbed = `
          <div class="video-embed">
            <div class="youtube-preview" data-video-id="${videoId}">
              <img src="${thumbUrl}" alt="YouTube video thumbnail" class="youtube-thumb" loading="lazy">
              <button class="youtube-play-btn" aria-label="Play video">
                <svg viewBox="0 0 68 48" width="68" height="48">
                  <path d="M66.52,7.74c-0.78-2.93-2.49-5.41-5.42-6.19C55.79,.13,34,0,34,0S12.21,.13,6.9,1.55C3.97,2.33,2.27,4.81,1.48,7.74C0.06,13.05,0,24,0,24s0.06,10.95,1.48,16.26c0.78,2.93,2.49,5.41,5.42,6.19C12.21,47.87,34,48,34,48s21.79-0.13,27.1-1.55c2.93-0.78,4.64-3.26,5.42-6.19C67.94,34.95,68,24,68,24S67.94,13.05,66.52,7.74z" fill="#FF0000"></path>
                  <path d="M 45,24 27,14 27,34" fill="#fff"></path>
                </svg>
              </button>
            </div>
            <a href="${youtubeUrl}" target="_blank" rel="noopener" class="youtube-direct-link">Watch on YouTube ‚Üó</a>
          </div>`;
      }
      
      // Display images for Pixelfed and Bluesky posts
      let mediaHtml = '';
      if (entry.media?.images && entry.media.images.length > 0) {
        const imagesHtml = entry.media.images.map((imgUrl: string, index: number) => {
          const alt = Array.isArray(entry.media.alt) ? entry.media.alt[index] || entry.media.alt[0] : (entry.media.alt || '');
          return `<img src="${imgUrl}" alt="${alt || 'Image'}" loading="lazy">`;
        }).join('');
        mediaHtml = `<div class="detail-media">${imagesHtml}</div>`;
      }
      
      // Parse content_html for notes and highlights
      let notesHtml = '';
      let highlightsHtml = '';
      if (entry.content_html) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(entry.content_html, 'text/html');
        
        // Extract notes
        const notesDiv = doc.querySelector('.notes');
        if (notesDiv && notesDiv.textContent?.trim()) {
          notesHtml = `<h4>Notes</h4><div class="notes-content">${notesDiv.innerHTML}</div>`;
        }
        
        // Extract highlights
        const highlightsDiv = doc.querySelector('.highlights');
        if (highlightsDiv) {
          const highlights = Array.from(highlightsDiv.querySelectorAll('li')).map(li => li.innerHTML);
          if (highlights.length > 0) {
            highlightsHtml = `<h4>Highlights</h4><ul class="highlights-list">${highlights.map(h => `<li>${h}</li>`).join('')}</ul>`;
          }
        }
      }
      
      // For HackerNews comments, add direct comment link
      let commentLinkHtml = '';
      if (entry.type === 'hackernews' && entry.metadata?.comment_url) {
        commentLinkHtml = `<div class="comment-direct-link"><a href="${entry.metadata.comment_url}" target="_blank" rel="noopener">Direct link to comment ‚Üó</a></div>`;
      }
      
      const mainContent = entry.summary ? `<p>${entry.summary}</p>` : '';
      let titleHtml = '';
      if (entry.title) {
        if (entry.type === 'hackernews' && (entry.url || entry.metadata?.story_url)) {
          const articleUrl = entry.metadata?.story_url || entry.url;
          titleHtml = `<h3 class="detail-title"><a href="${articleUrl}" target="_blank" rel="noopener" class="title-link">${entry.title} ‚Üó</a></h3>`;
        } else {
          titleHtml = `<h3 class="detail-title">${entry.title}</h3>`;
        }
      }
      
      // Build hashtags display
      let hashtagsHtml = '';
      if (entry.hashtags && entry.hashtags.length > 0) {
        const hashtagTags = entry.hashtags.map((tag: string) => 
          `<span class="detail-hashtag" data-hashtag="${tag}" role="button" tabindex="0">${tag}</span>`
        ).join('');
        hashtagsHtml = `<div class="detail-hashtags">${hashtagTags}</div>`;
      }
      
      content = `${titleHtml}
        ${youtubeEmbed}
        ${mediaHtml}
        <div class="detail-content">${mainContent}${commentLinkHtml}${metadataHtml}${notesHtml}${highlightsHtml}</div>
        ${hashtagsHtml}`;
    }
    
    // Check if comments should be disabled for this item
    const disableComments = checkCommentsDisabled(entry);
    
    // Add comments section with giscus for timeline items (if not disabled)
    if (!disableComments) {
      content += `
        <div class="panel-comments">
          <div class="giscus" id="giscus-${id}"></div>
        </div>
      `;
    }
    
    panelContent.innerHTML = content;
    
    // Add click handler for YouTube play button
    const ytPreview = panelContent.querySelector('.youtube-preview') as HTMLElement;
    if (ytPreview) {
      ytPreview.addEventListener('click', () => {
        const vid = ytPreview.dataset.videoId;
        if (!vid) return;
        const iframe = document.createElement('iframe');
        iframe.width = '560';
        iframe.height = '315';
        iframe.src = `https://www.youtube-nocookie.com/embed/${vid}?autoplay=1`;
        iframe.setAttribute('frameborder', '0');
        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
        iframe.allowFullscreen = true;
        ytPreview.replaceWith(iframe);
      });
    }

    // Add click handlers to detail hashtags
    panelContent.querySelectorAll('.detail-hashtag').forEach((tagEl) => {
      tagEl.addEventListener('click', (e) => {
        e.stopPropagation();
        const hashtag = (tagEl as HTMLElement).dataset.hashtag;
        if (hashtag) {
          window.dispatchEvent(new CustomEvent('hashtag:click', { detail: { tag: hashtag } }));
        }
      });
    });
    
    // Load giscus dynamically (if not disabled)
    if (!disableComments) {
      loadGiscus(id);
    }
    
    // Scroll to the node and update URL with hash
    const nodeId = `node-${id.replace(/[^a-zA-Z0-9-]/g, '-')}`;
    const nodeElement = document.getElementById(nodeId);
    if (nodeElement) {
      // Wait a bit for panel to open, then scroll
      setTimeout(() => {
        // Calculate offset for sticky header (if exists)
        const headerOffset = 150; // Approximate height of sticky controls
        const elementPosition = nodeElement.getBoundingClientRect().top;
        const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
        
        window.scrollTo({
          top: offsetPosition,
          behavior: 'smooth'
        });
        
        // Add a visual highlight temporarily
        nodeElement.classList.add('node-highlighted');
        setTimeout(() => {
          nodeElement.classList.remove('node-highlighted');
        }, 2000);
      }, 300);
    }
    
    // Update URL with hash anchor (preserve query params)
    const p = new URLSearchParams(location.search);
    const hash = `#${nodeId}`;
    const newUrl = p.toString() ? `?${p.toString()}${hash}` : hash;
    history.replaceState({}, '', newUrl);
  }

  function loadGiscus(nodeId: string) {
    // Remove any existing giscus script
    const existingScript = document.querySelector('script[src="https://giscus.app/client.js"]');
    if (existingScript) {
      existingScript.remove();
    }
    
    // Get the giscus container
    const container = document.getElementById(`giscus-${nodeId}`);
    if (!container) return;
    
    // Create new script element
    const script = document.createElement('script');
    script.src = 'https://giscus.app/client.js';
    script.setAttribute('data-repo', 'chasemp/timeline');
    script.setAttribute('data-repo-id', 'R_kgDOQDOMbA');
    script.setAttribute('data-category', 'Ideas');
    script.setAttribute('data-category-id', 'DIC_kwDOQDOMbM4CxLZb');
    script.setAttribute('data-mapping', 'specific');
    script.setAttribute('data-term', nodeId); // Use the node ID as the unique term
    script.setAttribute('data-strict', '0');
    script.setAttribute('data-reactions-enabled', '1');
    script.setAttribute('data-emit-metadata', '0');
    script.setAttribute('data-input-position', 'bottom');
    
    // Use appropriate theme based on current site theme
    const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
    script.setAttribute('data-theme', currentTheme === 'light' ? 'light' : 'dark');
    
    script.setAttribute('data-lang', 'en');
    script.setAttribute('crossorigin', 'anonymous');
    script.async = true;
    
    // Add error handling
    script.onerror = () => {
      // Hide comments section if script fails to load
      const commentsSection = container.closest('.panel-comments');
      if (commentsSection) {
        (commentsSection as HTMLElement).style.display = 'none';
      }
    };
    
    document.body.appendChild(script);
    
    // Also check after timeout if giscus loaded
    setTimeout(() => {
      if (container.innerHTML.trim() === '') {
        const commentsSection = container.closest('.panel-comments');
        if (commentsSection) {
          (commentsSection as HTMLElement).style.display = 'none';
        }
      }
    }, 10000);
  }

  function closePanel() {
    if (isMobile()) {
      backdrop.setAttribute('hidden', '');
      panel.classList.remove('mobile-detail-open');
      swipeIndicator.setAttribute('hidden', '');
      closeBtn.setAttribute('hidden', '');
      copyLinkBtn.setAttribute('hidden', '');
      lockScroll(false);
    }
    
    // Remove giscus when closing panel
    const existingScript = document.querySelector('script[src="https://giscus.app/client.js"]');
    if (existingScript) {
      existingScript.remove();
    }
    
    // Clear any giscus iframes
    const giscusElements = panelContent.querySelectorAll('.giscus');
    giscusElements.forEach(el => el.innerHTML = '');
    
    panelTitleText.textContent = 'About';
    panelSourceWrapper.setAttribute('hidden', '');
    panelContent.innerHTML = introHTML;
    closeBtn.setAttribute('hidden', '');
    copyLinkBtn.setAttribute('hidden', '');
    
    // Remove hash from URL (preserve query params)
    const p = new URLSearchParams(location.search);
    const newUrl = p.toString() ? `?${p.toString()}` : location.pathname;
    history.replaceState({}, '', newUrl);
  }
  
  // Copy link functionality
  copyLinkBtn.addEventListener('click', async () => {
    // Get the current URL including hash and query params
    const fullUrl = window.location.href;
    
    try {
      await navigator.clipboard.writeText(fullUrl);
      // Visual feedback
      const originalText = copyLinkBtn.textContent;
      copyLinkBtn.textContent = '‚úì';
      copyLinkBtn.classList.add('copied');
      setTimeout(() => {
        copyLinkBtn.textContent = originalText;
        copyLinkBtn.classList.remove('copied');
      }, 2000);
    } catch (err) {
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = fullUrl;
      textArea.style.position = 'fixed';
      textArea.style.opacity = '0';
      document.body.appendChild(textArea);
      textArea.select();
      try {
        document.execCommand('copy');
        const originalText = copyLinkBtn.textContent;
        copyLinkBtn.textContent = '‚úì';
        copyLinkBtn.classList.add('copied');
        setTimeout(() => {
          copyLinkBtn.textContent = originalText;
          copyLinkBtn.classList.remove('copied');
        }, 2000);
      } catch (fallbackErr) {
        console.error('Failed to copy link:', fallbackErr);
      }
      document.body.removeChild(textArea);
    }
  });

  function checkCommentsDisabled(entry: any): boolean {
    // Check global config
    const globalConfig = (window as any).__CONFIG__;
    
    // If global config disables comments site-wide, respect that
    if (globalConfig?.commentsEnabled === false) {
      return true;
    }
    
    // Check if comments are disabled for this content type (e.g., 'hackernews')
    // HackerNews entries are comments themselves, so no meta-comments needed
    if (globalConfig?.disableCommentsForTypes?.includes(entry.type)) {
      return true;
    }
    
    // Check for #nocomments or #nc hashtag
    const hashtags = entry.hashtags || [];
    const hasNoCommentsTag = hashtags.some((tag: string) => 
      tag.toLowerCase() === '#nocomments' || tag.toLowerCase() === '#nc'
    );
    
    // Check tags array as well (frontmatter tags)
    const tags = entry.tags || [];
    const hasNoCommentsInTags = tags.some((tag: string) => {
      const normalized = tag.toLowerCase().replace(/\s+/g, '_');
      return normalized === 'nocomments' || normalized === 'nc';
    });
    
    return hasNoCommentsTag || hasNoCommentsInTags;
  }

  closeBtn.addEventListener('click', closePanel);
  backdrop.addEventListener('click', closePanel);
  document.addEventListener('keydown', (e) => { 
    if (e.key === 'Escape' && (isMobile() ? panel.classList.contains('mobile-detail-open') : panelContent.innerHTML !== introHTML)) {
      closePanel();
    }
  });

  // Swipe down to close modal on mobile
  let touchStartY = 0;
  let touchStartTime = 0;
  let isSwipeGesture = false;

  panel.addEventListener('touchstart', (e) => {
    if (!isMobile() || !panel.classList.contains('mobile-detail-open')) return;
    
    touchStartY = e.touches[0].clientY;
    touchStartTime = Date.now();
    isSwipeGesture = false;
  }, { passive: true });

  panel.addEventListener('touchmove', (e) => {
    if (!isMobile() || !panel.classList.contains('mobile-detail-open')) return;
    
    const touchCurrentY = e.touches[0].clientY;
    const deltaY = touchCurrentY - touchStartY;
    const deltaTime = Date.now() - touchStartTime;
    
    // Check if this is a downward swipe gesture
    if (deltaY > 50 && deltaTime < 500) {
      isSwipeGesture = true;
      // Add visual feedback by slightly moving the panel down
      const translateY = Math.min(deltaY * 0.3, 100);
      panel.style.transform = `translateY(${translateY}px)`;
    }
  }, { passive: true });

  panel.addEventListener('touchend', (e) => {
    if (!isMobile() || !panel.classList.contains('mobile-detail-open')) return;
    
    const touchEndY = e.changedTouches[0].clientY;
    const deltaY = touchEndY - touchStartY;
    const deltaTime = Date.now() - touchStartTime;
    
    // Reset transform
    panel.style.transform = '';
    
    // Close if it's a valid swipe down gesture
    if (isSwipeGesture && deltaY > 100 && deltaTime < 500) {
      closePanel();
    }
    
    isSwipeGesture = false;
  }, { passive: true });

  // Add click handlers to all cards
  document.querySelectorAll('.card').forEach((btn) => {
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      openPanelFor((btn as HTMLElement).dataset.id!);
    });
  });

  // Tooltip
  const tooltip = document.getElementById('tooltip') as HTMLElement;
  const ttTitle = tooltip.querySelector('.tooltip-title') as HTMLElement;
  const ttMeta = tooltip.querySelector('.tooltip-meta') as HTMLElement;

  function positionTooltip(rect: DOMRect) {
    const gap = 10;
    const top = Math.min(window.innerHeight - 80, Math.max(0, rect.top + window.scrollY + gap));
    const left = Math.min(window.innerWidth - 380, Math.max(0, rect.left + window.scrollX + gap));
    tooltip.style.top = `${top}px`;
    tooltip.style.left = `${left}px`;
  }

  // Tooltips only for dots (removed from cards)
  // No tooltip function needed - using native title attribute on dots

  // Enhanced tooltips for top bar showing date with emoji
  function showCardTooltip(topBar: HTMLElement) {
    const timestamp = topBar.dataset.timestamp!;
    const type = topBar.dataset.cardType!;
    const date = new Date(timestamp).toLocaleString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    });

    const emojiMap: Record<string, string> = {
      'blog': 'üìù',
      'saved': 'üîñ',
      'primer': 'üß†',
      'bluesky': 'ü¶ã',
      'pixelfed': 'üì∑',
      'hackernews': 'üí¨',
      'posts': 'ü¶ã',
      'release': 'üè∑Ô∏è',
      'wikipedia': 'üåê',
      'contributions': 'üåê',
      'linkedin': 'üíº'
    };

    const typeDisplayNames: Record<string, string> = {
      'saved': 'Article Shared',
      'primer': 'AI Topic Primer',
      'bluesky': 'Posts',
      'pixelfed': 'Photo',
      'hackernews': 'Comment',
      'posts': 'Posts',
      'wikipedia': 'Contributions',
      'contributions': 'Contributions',
      'linkedin': 'LinkedIn'
    };
    
    const emoji = emojiMap[type] || '';
    const displayName = typeDisplayNames[type] || type.toUpperCase();
    ttTitle.textContent = `${emoji} ${displayName}`;
    ttMeta.textContent = date;
    positionTooltip(topBar.getBoundingClientRect());
    tooltip.removeAttribute('hidden');
  }
  function hideCardTooltip() {
    tooltip.setAttribute('hidden', '');
  }

  // Tooltip only shows on top bar hover, not whole card
  document.querySelectorAll('.card-top-bar').forEach((topBar) => {
    const tb = topBar as HTMLElement;
    tb.addEventListener('mouseenter', () => showCardTooltip(tb));
    tb.addEventListener('mouseleave', hideCardTooltip);
  });

  // Handle hash navigation (anchor links)
  function handleHashNavigation() {
    const hash = location.hash;
    if (hash && hash.startsWith('#node-')) {
      // Find the node element directly by ID
      const nodeElement = document.querySelector(hash);
      if (nodeElement) {
        const rowId = (nodeElement as HTMLElement).dataset.id;
        if (rowId) {
          // Small delay to ensure DOM is ready
          setTimeout(() => {
            openPanelFor(rowId);
          }, 100);
          return;
        }
      }
    }
    
    // Fallback to query param for backwards compatibility
    const selectedId = params.get('id');
    if (selectedId) {
      setTimeout(() => {
        openPanelFor(selectedId);
      }, 100);
    }
  }
  
  // Handle hash changes
  window.addEventListener('hashchange', handleHashNavigation);
  
  // Handle initial load
  handleHashNavigation();
</script>

<style>
  .timeline { display: contents; }
  .empty-state { text-align: center; padding: 80px 20px; color: var(--muted); max-width: 600px; margin: 0 auto; }
  .empty-icon { font-size: 64px; margin-bottom: 20px; opacity: 0.8; }
  .empty-state h3 { font-size: 24px; color: var(--text); margin: 0 0 12px; font-weight: 600; }
  .empty-state p { margin: 8px 0; font-size: 16px; line-height: 1.6; }
  .empty-state strong { color: var(--accent); }
  .reset-link { color: var(--accent); text-decoration: underline; cursor: pointer; font-weight: 600; }
  .reset-link:hover { opacity: 0.8; }
  
  /* Timeline list with centered vertical line */
  .list { 
    list-style: none; 
    margin: 0; 
    padding: 0; 
    position: relative; 
  }
  .list::before {
    content: "";
    position: absolute;
    top: 0;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 2px;
    background: var(--spine);
    z-index: 0;
  }
  
  /* Each row - card centered */
  .row { 
    position: relative;
    margin: 0;
    padding-top: 16px;
    transition: background-color 0.3s ease; 
  }
  .row.node-highlighted { background-color: rgba(193, 122, 79, 0.15); border-radius: 8px; }
  
  /* Today dot - only for today marker */
  .dot { 
    position: absolute; 
    left: 50%; 
    top: 0;
    transform: translateX(-50%);
    width: 14px; 
    height: 14px; 
    border-radius: 50%; 
    background: var(--accent); 
    box-shadow: 0 0 0 3px var(--bg); 
    cursor: default; 
    border: 1px solid rgba(0,0,0,0.1); 
    z-index: 2;
  }
  
  /* Today marker styles */
  .today-marker { padding-top: 12px; margin-bottom: 12px; }
  .today-dot { background: var(--accent); cursor: default; animation: pulse 2s ease-in-out infinite; top: 0; }
  .today-dot:hover { transform: translateX(-50%); box-shadow: 0 0 0 3px var(--bg); }
  .today-label { 
    display: flex; 
    align-items: center; 
    justify-content: center;
    gap: 8px; 
    padding-top: 8px;
  }
  .today-text { font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; font-size: 13px; color: var(--accent); font-family: system-ui, sans-serif; }
  .today-date { color: var(--muted); font-size: 13px; font-family: system-ui, sans-serif; }
  @keyframes pulse {
    0%, 100% { box-shadow: 0 0 0 3px var(--bg), 0 0 0 4px var(--accent); }
    50% { box-shadow: 0 0 0 3px var(--bg), 0 0 0 6px var(--accent), 0 0 16px var(--accent); }
  }
  
  /* Card styles */
  .card { 
    text-align: left; 
    background: var(--card-bg); 
    color: var(--text); 
    border: 1px solid var(--border); 
    border-radius: 8px; 
    padding: 14px; 
    padding-top: 18px; /* Extra space for top bar */
    cursor: pointer; 
    width: 100%; 
    transition: all 0.2s; 
    box-shadow: 0 1px 3px rgba(0,0,0,0.05); 
    position: relative; 
    z-index: 1;
    overflow: visible;
  }
  .card:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.1); transform: translateY(-1px); }
  
  /* Top bar - hover target for tooltip */
  .card-top-bar {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    border-radius: 8px 8px 0 0;
    cursor: pointer;
    z-index: 3;
    transition: all 0.2s ease;
  }
  .card-top-bar:hover {
    height: 6px;
    filter: brightness(1.2);
  }
  
  /* Emoji indicator on top bar hover */
  .card-top-bar::after {
    content: "";
    position: absolute;
    top: -16px;
    right: 12px;
    font-size: 20px;
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
  }
  .card-top-bar:hover::after { opacity: 1; }
  
  /* Top bar colors by type */
  .card-top-bar[data-card-type="blog"] { background: #5d4037; }
  .card-top-bar[data-card-type="saved"] { background: #7cb342; }
  .card-top-bar[data-card-type="primer"] { background: #7e57c2; }
  .card-top-bar[data-card-type="bluesky"] { background: #1e88e5; }
  .card-top-bar[data-card-type="pixelfed"] { background: #e91e63; }
  .card-top-bar[data-card-type="hackernews"] { background: #ff6600; }
  .card-top-bar[data-card-type="posts"] { background: #42a5f5; }
  .card-top-bar[data-card-type="release"] { background: #fb8c00; }
  .card-top-bar[data-card-type="wikipedia"] { background: #636466; }
  .card-top-bar[data-card-type="contributions"] { background: #9c27b0; }
  .card-top-bar[data-card-type="linkedin"] { background: #0a66c2; }
  
  /* Emoji by type on top bar hover */
  .card-top-bar[data-card-type="blog"]::after { content: "üìù"; }
  .card-top-bar[data-card-type="saved"]::after { content: "üîñ"; }
  .card-top-bar[data-card-type="primer"]::after { content: "üß†"; }
  .card-top-bar[data-card-type="bluesky"]::after { content: "ü¶ã"; }
  .card-top-bar[data-card-type="pixelfed"]::after { content: "üì∑"; }
  .card-top-bar[data-card-type="hackernews"]::after { content: "üí¨"; }
  .card-top-bar[data-card-type="posts"]::after { content: "ü¶ã"; }
  .card-top-bar[data-card-type="release"]::after { content: "üè∑Ô∏è"; }
  .card-top-bar[data-card-type="wikipedia"]::after { content: "üåê"; }
  .card-top-bar[data-card-type="contributions"]::after { content: "üåê"; }
  .card-top-bar[data-card-type="linkedin"]::after { content: "üíº"; }
  
  .card-link { display: block; text-decoration: none; }
  .meta { display: flex; gap: 10px; font-size: 12px; color: var(--muted); font-family: system-ui, sans-serif; align-items: center; }
  .type { text-transform: uppercase; letter-spacing: .08em; font-weight: 600; }
  .media-indicator { background: rgba(193, 122, 79, 0.15); padding: 2px 6px; border-radius: 4px; font-size: 11px; color: var(--accent); white-space: nowrap; }
  .media-preview { position: relative; display: flex; justify-content: center; margin: 8px 0; }
  .preview-image { width: 126px; height: 126px; border-radius: 8px; object-fit: cover; border: 1px solid var(--border); transition: transform 0.2s; }
  .preview-image:hover { transform: scale(1.05); }
  .image-count { position: absolute; top: -6px; right: -6px; background: var(--accent); color: var(--bg); font-size: 10px; font-weight: 600; padding: 2px 4px; border-radius: 8px; min-width: 16px; text-align: center; line-height: 1; }
  .title { font-weight: 600; margin-top: 6px; color: var(--text); line-height: 1.4; }
  .title-link { text-decoration: none; color: var(--text); display: block; transition: color 0.2s; }
  .title-link:hover { color: var(--accent); text-decoration: underline; }
  .summary { margin: 8px 0 0; color: var(--muted); font-size: 14px; line-height: 1.5; }
  .card-metadata { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border); }
  .metadata-item { font-size: 12px; color: var(--muted); font-family: system-ui, sans-serif; display: flex; align-items: center; gap: 4px; }
  .card-hashtags { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 8px; }
  .card-hashtag { display: inline-block; padding: 2px 8px; border-radius: 999px; background: rgba(193, 122, 79, 0.15); color: var(--accent); font-size: 11px; font-weight: 600; font-family: system-ui, sans-serif; border: 1px solid transparent; cursor: pointer; transition: all 0.2s; }
  .card-hashtag:hover { background: rgba(193, 122, 79, 0.25); border-color: var(--accent); transform: scale(1.05); }
  .card-hashtag:active { transform: scale(0.95); }
  .card-hashtag.hashtag-selected { background: var(--accent); color: var(--bg); border-color: var(--accent); }
  .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }

  #tooltip { position: fixed; z-index: 60; pointer-events: none; }
  .tooltip-card { background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 10px 12px; box-shadow: 0 4px 16px rgba(0,0,0,0.15); max-width: 360px; }
  .tooltip-title { font-weight: 600; font-size: 14px; margin-bottom: 3px; color: var(--text); }
  .tooltip-meta { font-size: 12px; color: var(--muted); font-family: system-ui, sans-serif; }
  
  /* YouTube video embed */
  .video-embed {
    margin: 20px 0;
    max-width: 100%;
    overflow: hidden;
    box-sizing: border-box;
  }
  .video-embed iframe {
    width: 100% !important;
    max-width: 100% !important;
    height: auto !important;
    aspect-ratio: 16 / 9;
    border-radius: 8px;
    box-sizing: border-box;
  }
  .youtube-preview {
    position: relative;
    cursor: pointer;
    border-radius: 8px;
    overflow: hidden;
    aspect-ratio: 16 / 9;
    background: #000;
  }
  .youtube-preview:hover .youtube-play-btn svg path:first-child {
    fill: #f00;
    opacity: 1;
  }
  .youtube-thumb {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
  }
  .youtube-play-btn {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
    filter: drop-shadow(0 2px 8px rgba(0,0,0,0.4));
    transition: transform 0.2s;
  }
  .youtube-preview:hover .youtube-play-btn {
    transform: translate(-50%, -50%) scale(1.1);
  }
  .youtube-play-btn svg path:first-child {
    fill: rgba(0,0,0,0.7);
    transition: fill 0.2s;
  }
  .youtube-direct-link {
    display: inline-block;
    margin-top: 8px;
    font-size: 13px;
    color: var(--accent, #c17a4f);
    text-decoration: none;
    font-weight: 600;
  }
  .youtube-direct-link:hover {
    text-decoration: underline;
  }
  
  /* Detail media (images from Pixelfed/Bluesky) */
  .detail-media { 
    margin: 20px 0; 
    max-width: 100%;
    overflow: hidden;
    box-sizing: border-box;
  }
  .detail-media img { 
    width: 100% !important; 
    max-width: 100% !important; 
    height: auto !important; 
    border-radius: 8px; 
    margin: 12px 0; 
    border: 1px solid var(--border); 
    display: block; 
    object-fit: contain;
    box-sizing: border-box;
  }
  .detail-media img:first-child { margin-top: 0; }
  .detail-media img:last-child { margin-bottom: 0; }
  
  /* Notes and highlights sections */
  .notes-content { margin: 16px 0; padding: 16px; background: rgba(193, 122, 79, 0.1); border-left: 3px solid var(--accent); border-radius: 4px; font-style: italic; color: var(--text); }
  .highlights-list { margin: 16px 0; padding-left: 24px; list-style: disc; }
  .highlights-list li { margin: 12px 0; color: var(--text); line-height: 1.6; }
  
  /* HackerNews article title link in detail panel */
  :global(.detail-title .title-link) { text-decoration: none; color: var(--accent); transition: color 0.2s; }
  :global(.detail-title .title-link:hover) { text-decoration: underline; }

  /* HackerNews direct comment link */
  .comment-direct-link { margin: 16px 0; padding: 12px; background: rgba(255, 102, 0, 0.1); border-left: 3px solid #ff6600; border-radius: 4px; }
  .comment-direct-link a { color: #ff6600; font-weight: 600; text-decoration: none; font-size: 14px; }
  .comment-direct-link a:hover { text-decoration: underline; }
  
  /* Detail page hashtags - centered below content */
  /* Using :global() because these are dynamically injected via JS */
  :global(.detail-hashtags) {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    margin: 24px 0;
    padding-top: 20px;
    border-top: 1px solid var(--border);
  }
  :global(.detail-hashtag) {
    display: inline-block;
    padding: 4px 12px;
    border-radius: 999px;
    background: rgba(193, 122, 79, 0.15);
    color: var(--accent);
    font-size: 12px;
    font-weight: 600;
    font-family: system-ui, sans-serif;
    border: 1px solid transparent;
    cursor: pointer;
    transition: all 0.2s;
  }
  :global(.detail-hashtag:hover) {
    background: rgba(193, 122, 79, 0.25);
    border-color: var(--accent);
    transform: scale(1.05);
  }
  :global(.detail-hashtag:active) {
    transform: scale(0.95);
  }
</style>

